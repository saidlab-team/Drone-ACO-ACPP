close all
clc
clear
format shortEng;

%------------------------------------------------------------------------
% CITIES
%------------------------------------------------------------------------

c10 = [1 1];
c9 = [2 1];
c8 = [3 1];
c7 = [4 1];
c6 = [5 1];
c5 = [6 1];
c4 = [7 1];
c3 = [8 1];

d10 = [1 2];
d9 = [2 2];
d8 = [3 2];
d7 = [4 2];
d6 = [5 2];
d5 = [6 2];
d4 = [7 2];
d3 = [8 2];

e10 = [1 3];
e9 = [2 3];
e8 = [3 3];
e7 = [4 3];
e6 = [5 3];
e5 = [6 3];
e4 = [7 3];
e3 = [8 3];

f10 = [1 4];
f9 = [2 4];
f8 = [3 4];
f7 = [4 4];
f6 = [5 4];
f5 = [6 4];
f4 = [7 4];
f3 = [8 4];

g10 = [1 5];
g9 = [2 5];
g8 = [3 5];
g7 = [4 5];
g6 = [5 5];
g5 = [6 5];
g4 = [7 5];
g3 = [8 5];

h10 = [1 6];
h9 = [2 6];
h8 = [3 6];
h7 = [4 6];
h6 = [5 6];
h5 = [6 6];
h4 = [7 6];
h3 = [8 6];

cities = [c10;  d10;   e10;	 f10;   g10;  h10; 
          c9;   d9;    e9;   f9;    g9;   h9;	
          c8;   d8;    e8;   f8;    g8;   h8;	
	      c7;	d7;	   e7;	 f7;	g7;	  h7;	
	      c6;	d6;	   e6;	 f6;	g6;	  h6;
	      c5;	d5;	   e5;	 f5;	g5;	  h5;	
	      c4;	d4;	   e4;	 f4;	g4;	  h4;
	      c3;	d3;	   e3;	 f3;	g3;	  h3];
     
% Number of cities
nCities = length(cities);

% Number of forbidden cities
forbiCitI = [c3 ;f10; f3; g8; g3; h6; h3; h4];
forbiddenCitiesI = find(ismember(cities,forbiCitI,'row'));
nForbiddenCities = length(forbiddenCitiesI);

%-------------------------------------------------------------------------
% -1. ACPP PARAMETERS
%-------------------------------------------------------------------------

% Grid workspace representation
rows = 8;
columns = 6;
this_workspace = [rows columns];

% Initial and final position

SttPotGlI = [c10; h5];
StartPointGlobal = find(ismember(cities,SttPotGlI,'row'));

% Number of robots
nRobots = length(StartPointGlobal);

% Size of each path
nCitiesGlobal = nCities - nForbiddenCities;
nPoints = floor( nCitiesGlobal / nRobots );
nPaths = nPoints.*ones(nRobots,1);

if(nCitiesGlobal > sum(nPaths))
    r = randi(nRobots,1);
    nPaths(r) = nPaths(r) + 1;
end

Paths = cell(nRobots,1);

%------------------------------------------------------------------------
% 0. INITIALIZE PARAMETERS
%------------------------------------------------------------------------

% Number of ants
nAnts = nCities - nForbiddenCities ;

% Pheromone evaporation rate
rho = 0.02;

%------------------------------------------------------------------------
% 1. INITIALIZE PHEROMONE
%------------------------------------------------------------------------

% Tour generated by the nereast neighbour heuristic
% StartPointGlobal(k=1) is the default first position
[t, tL] = NNS(cities, forbiddenCitiesI, StartPointGlobal(1));

Cnn = tL / nRobots;

% Initial pheromone trail
t0 = 1 / ( ( nCities - nForbiddenCities) * Cnn );

% Matrix of pheromone trails
pheromonesMemoryInit = t0*ones(nCities);
pheromonesMemoryInit( logical( eye( size(pheromonesMemoryInit) ) ) ) = 0;
pheromonesMemory = cell(1,nRobots);

%------------------------------------------------------------------------
% 2. TOUR CONSTRUCTION
%------------------------------------------------------------------------

%------------------------------------------------------------------------
% 2.1. INITIALIZE TOURS
%------------------------------------------------------------------------

% Parameters
stopParameter = 1500;

% Determine the relative influence of the pheromone trail and the
% heurisitic information
alpha = 1;
beta = 2;

% Plotting purpose only!
minTourLengths = zeros(stopParameter-1,2);
meanTourLengths = zeros(stopParameter-1,1);

nIterations = 1;
minimum = inf;
bsMinimum = inf;

% Global grid bmap
gridMapGlobal = ones(rows,columns);

% The global map obstacles
gridMapGlobal(forbiddenCitiesI) = 0;

% Adjacent Initial points (AIP)
gridMapGlobal(StartPointGlobal) = 0;

tic

Tours = cell(1,nRobots);
TourArcs = cell(1,nRobots);

% The initials positions are assigned randomly to the robots
StartPointGlobal = StartPointGlobal(randperm(length(StartPointGlobal)));

for k=1:nRobots
    
    startP = StartPointGlobal(k);
    
    % Force start position
    Tours{k} = startP.*ones(nAnts,nCities);
    Tours{k}(:,2:end) = 0;
    
    TourArcs{k} = zeros(nAnts, nCities);
    
end

while(nIterations <= stopParameter)
    
    TourLengths = zeros(nAnts, 1);
    avg = cell(1,nRobots);
    [avg{1,1:nRobots}] = deal(zeros(nAnts,1));
    [pheromonesMemory{1,1:nRobots}] = deal(pheromonesMemoryInit);
    
    for i=1:nAnts
        
        citiesInd = 1:(rows*columns);

        % Point marked as forbidden
        citiesInd(forbiddenCitiesI) = 0;
        
        % Adjacent initial points (AIP) marked as forbidden
        citiesInd(StartPointGlobal) = 0;
        
        % Local copy of grid map
        gridMap = gridMapGlobal;
        
        pheromones = zeros(1,nCities);
        
         for k=1:nRobots
                

            for j=1:(nCitiesGlobal-(nCitiesGlobal-nPaths(k))-1)

  
         
                % Point to visit
                cityInd = Tours{k}(i,j);
                
                % Point neighbours (Moore neighborhood)
                neigbours = NNFc(gridMap, cityInd);
                
                if( isempty(neigbours) )
                    
                    freePoints = find(gridMap == 1);
                    
                    StartPCoordinates = ones( length(freePoints) , 1 )*cities(cityInd,:);
                    
                    freePointsCoordinates = cities(freePoints,:);
                    
                    Tourlength = sqrt( sum( ( freePointsCoordinates - StartPCoordinates).^2, 2 ) );
                    
                    neigbours  = freePoints( Tourlength == min(Tourlength) );
                    
                    neigbours = nonzeros(citiesInd(neigbours));
                    
                end
                
                avg{k}(i) = avg{k}(i) + length(neigbours);
                
                % Picks the pheromone values from the pheromone matrix from an
                % ant tour
                pheromones(neigbours) = pheromonesMemory{k}(cityInd,neigbours);
                
                %------------------------------------------------------------------------
                % 2.2. RANDOM PROPORTIONAL RULE
                %------------------------------------------------------------------------
                
                [maxProb,maxProbI] = RPR(cityInd, citiesInd, cities, pheromones, alpha, beta);
                
                if(~isempty(maxProbI))
                    
                    % Update tours
                    Tours{k}(i, j+1) = maxProbI;
                    
                    % Update arcs
                    TourArcs{k}(i,j) = sub2ind(size(pheromonesMemory{k}),Tours{k}(i, j),Tours{k}(i, j+1));
                    
                    % Verify if the tour length finished
                    if(j == ( nCitiesGlobal - ( nCitiesGlobal - nPaths(k) ) - 1 ) )
                        
                        % Update tours
                        Tours{k}(i, j+2:end) = Tours{k}(i, j+1);
                        
                        % Update arcs
                        TourArcs{k}(i,j+1:end) = TourArcs{k}(i,j);
                        
                    end
                    
                end
                
                % Point marked as visited
                citiesInd(Tours{k}(i, j+1)) = 0; %ERRRORRRRR
                gridMap(Tours{k}(i, j+1)) = 0;
                pheromones(Tours{k}(i, j+1)) = 0;
                
            end
            
        end
        
        for k=1:nRobots
            
            % Update TourArcs
            TourArcs{k}(i,end) = sub2ind(size(pheromonesMemory{k}),Tours{k}(i, end),Tours{k}(i, 1));
            
            % Update TourLength -> Path length
            pathLength = lengthFc(Tours{k}(i,:), Tours{k}(i,:), cities);            
            TourLengths(i) =  TourLengths(i) + pathLength;
            
        end
        
        % Update TourLength -> Distance between robots (iff the number of robots > 1)
        if (nRobots > 1)
            pathDistance = distanceFc(Tours, cities, i);
            TourLengths(i) =  TourLengths(i) + pathDistance;
        end
        
    end
    
    % Best-so-far tour, tour length and tour arcs
    [bs,bsI] = min(TourLengths);
    
    if(bs < bsMinimum)
        bsMinimum = bs;
        bsTour = cell(1,nRobots);
        bsTourArcs = cell(1,nRobots);
        bsAvg = cell(1,nRobots);
        for k=1:nRobots
            bsTour{k} = Tours{k}(bsI,:);
            bsTourArcs{k} = TourArcs{k}(bsI,:);
            bsAvg{k} = avg{k}(bsI);
        end        
    end
    
    % Iteration-best tour, tour length and tour arcs
    ibMinimum = bs;
    ibTour = cell(1,nRobots);
    ibTourArcs = cell(1,nRobots);
    ibAvg = cell(1,nRobots);
    for k=1:nRobots
        ibTour{k} = Tours{k}(bsI,:);
        ibTourArcs{k} = TourArcs{k}(bsI,:);
        ibAvg{k} = avg{k}(bsI);
    end
    
    %------------------------------------------------------------------------
    % 2.3. PHEROMONE TRAIL LIMITS
    %------------------------------------------------------------------------
    
    % Small TSP instance -> Iteration-best
    bTour = bsTour;
    bTourLengths = bsMinimum;
    bTourArcs = bsTourArcs;
    bAvg = bsAvg;
        
    % The average is given by the 'avg = number of opcions for one ant' /
    % The total of options available is all cities less the forbidden and
    % the number of robots (two initial positions pre-defined)
    bAvg = cell2mat(bAvg) ./ nPaths' ;
    
    tLimits = PheTrlLim(bsMinimum, rho, bAvg, nCities);
    
    %------------------------------------------------------------------------
    % 2.4. UPDATE OF PHEROMONE TRAILS
    %------------------------------------------------------------------------
    
    pheromonesMemory = updatePheTrl(pheromonesMemory, bTourLengths, bTourArcs, rho, tLimits);
    
%     [minTourLength, minTourLengthI] = min(TourLengths);
    
%     if(minTourLength < minimum)
%         minTour = cell(1,nRobots);
%         for k=1:nRobots
%             minTourI = Tours{k}(minTourLengthI(1),:);
%             minTour{k} = cities(minTourI,:);
%         end
%         minimum = minTourLength;
%     end
    
    minimum = bsMinimum;

    minTourLengths(nIterations,:) = [minimum ibMinimum];
    
    meanTourLengths(nIterations) = mean(TourLengths);
    
    nIterations = nIterations + 1;
    
    %----------------------------------------------------------------------
    % 2.5. PHEROMONE TRAIL (RE)INITIALIZATION
    %----------------------------------------------------------------------
    
    if(nIterations > stopParameter)
        
        % If the minimum value obtained with ACO is bigger than a full coverage path, the (re)initialize
        if(minimum >= (Cnn*nRobots) + nRobots)
            
            nIterations = 1;
            
            % Tour generated by the nereat neighbour heuristic
            [t, tL] = NNS(cities, forbiddenCitiesI, startP);
            
            Cnn = tL / nRobots;
            
            % Initial pheromone trail
            t0 = 1 / ( ( nCities - nForbiddenCities ) * Cnn );
            
            % Matrix of pheromone trails
            pheromonesMemoryInit = t0*ones(nCities);
            pheromonesMemoryInit( logical( eye( size(pheromonesMemoryInit) ) ) ) = 0;
            pheromonesMemory = cell(1,nRobots);
            
        end
        
    end
         
end

toc

disp(['Number of robots: ', num2str(nRobots)]);
disp(['Number of ants: ', num2str(nAnts)]);
disp(['Number of cities: ', num2str(sum(nPaths))]);
disp(['Iterations: ', num2str(stopParameter)]);
disp(['alpha: ', num2str(alpha)]);
disp(['beta: ', num2str(beta)]);
disp(['rho: ', num2str(rho)]);
%disp(['Start positions: ', num2str(StartPointGlobal)]);
disp(['Tour length (NNS): ', num2str(Cnn*nRobots)]);
disp(['Tour length (ACO): ', num2str(minimum)]);

figure(1);
hold on;

% Cities
plot(cities(:,2), cities(:,1),'ksq','linewidth', 2);

% Obstacles
% Lines are y-axis and columns are x-axis

% w = zeros(length(forbiddenCitiesI),2);
% [row,col] = ind2sub([28], forbiddenCitiesI);
% w(:,1) = row';
% w(:,2) = col';

w = cities(forbiddenCitiesI,:);

obs_xy = LC2XY(w, this_workspace);

plot(obs_xy(:,1), obs_xy(:,2),'rsq','linewidth', 4);

% for i=1:nRobots
%     
%     %convert to XY
% 
%     w = zeros(length(bTour{i}),2); %not sure if the indexes of btour are the same as the ones from the matrix...or the indexes belong to other matrix used before
%     [row,col] = ind2sub(this_workspace, bTour{i});
%     w(:,1) = row';
%     w(:,2) = col';
%     
%     thisPath = LC2XY(w, this_workspace);
%     
%     % Start and End positions
%     plot(thisPath(1,1),thisPath(1,2),'go','linewidth', 4);
%     plot(thisPath(end-1,1),thisPath(end-1,2),'bo','linewidth', 4);
% 
%     % return to home position
% 
%     thisPath(end,:) = thisPath(1,:);
% 
%     % MMAS path
%     gcf =plot(thisPath(:,1), thisPath(:,2),'y-','linewidth', 2);
%     set(gcf, 'Color', rand(1,3));
%     
%     %[num map] = TurnsImproved(Paths{i},[rows columns])
%     
% end

for i=1:nRobots
    
    Paths{i} = cities(bTour{i},:);
 
    obs_xy = LC2XY(Paths{i}, this_workspace);
    
    thisPath = zeros( length( obs_xy ) + 1, 2 );
    thisPath(1:length( obs_xy ),:) = obs_xy;
    
    % Start and End positions
    plot(thisPath(1,1),thisPath(1,2),'go','linewidth', 4);
    plot(thisPath(end-1,1),thisPath(end-1,2),'bo','linewidth', 4);
    
    thisPath(end,:) = thisPath(1,:);
    
    % MMAS path
    gcf =plot(thisPath(:,1), thisPath(:,2),'y-','linewidth', 2);
    set(gcf, 'Color', rand(1,3));
     
end


% figure(2);
% 
% subplot(1,3,1);
% plot(1:stopParameter, minTourLengths(:,1),'k-','linewidth', 2);
% xlabel('number of iterations');
% ylabel('cost');
% axis auto
% 
% subplot(1,3,2);
% plot(1:stopParameter, minTourLengths(:,2),'g-');
% xlabel('number of iterations');
% ylabel('min iter cost (lenght)');
% axis auto
% 
% subplot(1,3,3);
% plot(1:stopParameter, meanTourLengths,'r-');
% xlabel('Number of iterations');
% ylabel('mean cost (lenght)');
% axis auto
%     
% figure(4);
% 
% for i=1:nRobots
%     subplot(1,nRobots,i);
%     pher1 = surf(1:nCities, nCities:-1:1, pheromonesMemory{i});
%     view(2);
% end
% 
% if (nRobots == 2)
%     
%     figure(5);
%     hold;
%     Distance12 = sqrt( sum( ( Paths{1} - Paths{2} ).^2, 2 ) );
%     Time = 1:nCities;
%     plot(Time, Distance12, 'r', 'linewidth', 2);
%     legend('Distance12');
%     xlabel('way-points');
%     ylabel('distance between drones');
%     axis square
%     
% elseif (nRobots == 3)
%     
%     figure(5);
%     hold;
%     Distance12 = sqrt( sum( ( Paths{1} - Paths{2} ).^2, 2 ) );
%     Distance13 = sqrt( sum( ( Paths{1} - Paths{3} ).^2, 2 ) );
%     Distance23 = sqrt( sum( ( Paths{2} - Paths{3} ).^2, 2 ) );
%     Time = 1:nCities;
%     plot(Time, Distance12, 'r', 'linewidth', 2);
%     plot(Time, Distance23, 'b', 'linewidth', 2);
%     plot(Time, Distance13, 'k', 'linewidth', 2);
%     legend('Distance12','Distance23','Distance13');
%     xlabel('way-points');
%     ylabel('distance between drones');
%     axis square
%     
% end

return